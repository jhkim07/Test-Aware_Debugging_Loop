{"instance_id": "astropy__astropy-14365", "model_patch": "diff --git a/astropy/io/ascii/tests/test_qdp.py b/astropy/io/ascii/tests/test_qdp.py\nindex 1234567..89abcde 100644\n--- a/astropy/io/ascii/tests/test_qdp.py\n+++ b/astropy/io/ascii/tests/test_qdp.py\n@@ -81,2 +81,24 @@\n     path = str(tmp_path / \"test.qdp\")\n     path2 = str(tmp_path / \"test2.qdp\")\n\n+def test_lowercase_qdp_commands(tmp_path):\n+    \"\"\"\n+    Test that QDP files with lowercase commands are read correctly.\n+    This test reproduces the bug where lowercase QDP commands would cause a crash.\n+    \"\"\"\n+    qdp_content = \"\"\"\n+    read serr 1 2\n+    1 0.5 1 0.5\n+    \"\"\"\n+    path = tmp_path / \"lowercase_test.qdp\"\n+    path.write_text(qdp_content)\n+\n+    from astropy.table import Table\n+    table = Table.read(path, format='ascii.qdp')\n+\n+    # Expected data: two columns with errors\n+    expected_data = [\n+        (1.0, 0.5, 1.0, 0.5)\n+    ]\n+\n+    assert len(table) == 1\n+    assert table[0] == expected_data[0]\n\n--- a/astropy/io/ascii/qdp.py\n+++ b/astropy/io/ascii/qdp.py\n@@ -18,6 +18,71 @@\n def _line_type(line, delimiter=None):\n+    \"\"\"Interpret a QDP file line.\n+\n+    Parameters\n+    ----------\n+    line : str\n+        a single line of the file\n+\n+    Returns\n+    -------\n+    type : str\n+        Line type: \"comment\", \"command\", or \"data\"\n+\n+    Examples\n+    --------\n+    >>> _line_type(\"READ SERR 3\")\n+    'command'\n+    >>> _line_type(\" \\n    !some gibberish\")\n+    'comment'\n+    >>> _line_type(\"   \")\n+    'comment'\n+    >>> _line_type(\" 21345.45\")\n+    'data,1'\n+    >>> _line_type(\" 21345.45 1.53e-3 1e-3 .04 NO nan\")\n+    'data,6'\n+    >>> _line_type(\" 21345.45,1.53e-3,1e-3,.04,NO,nan\", delimiter=',')\n+    'data,6'\n+    >>> _line_type(\" 21345.45 ! a comment to disturb\")\n+    'data,1'\n+    >>> _line_type(\"NO NO NO NO NO\")\n+    'new'\n+    >>> _line_type(\"NO,NO,NO,NO,NO\", delimiter=',')\n+    'new'\n+    >>> _line_type(\"N O N NOON OON O\")\n+    Traceback (most recent call last):\n+        ...\n+    ValueError: Unrecognized QDP line...\n+    >>> _line_type(\" some non-comment gibberish\")\n+    Traceback (most recent call last):\n+        ...\n+    ValueError: Unrecognized QDP line...\n+    \"\"\"\n+    _decimal_re = r\"[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?\"\n+    _command_re = r\"READ [TS]ERR(\\s+[0-9]+)+\"\n+\n+    sep = delimiter\n+    if delimiter is None:\n+        sep = r\"\\s+\"\n+    _new_re = rf\"NO({sep}NO)+\"\n+    _data_re = rf\"({_decimal_re}|NO|[-+]?nan)({sep}({_decimal_re}|NO|[-+]?nan))*)\"\n+    _type_re = rf\"^\\s*((?P<command>{_command_re})|(?P<new>{_new_re})|(?P<data>{_data_re})?\\s*(\\!(?P<comment>.*))?\\s*$\"\n+    _line_type_re = re.compile(_type_re, re.IGNORECASE)\n+    line = line.strip()\n+    if not line:\n+        return \"comment\"\n+    match = _line_type_re.match(line)\n+\n+    if match is None:\n+        raise ValueError(f\"Unrecognized QDP line: {line}\")\n+    for type_, val in match.groupdict().items():\n+        if val is None:\n+            continue\n+        if type_ == \"data\":\n+            return f\"data,{len(val.split(sep=delimiter))}\"\n+        else:\n+            return type_\n     \"\"\"Interpret a QDP file line.\n\n     Parameters\n@@ -306,6 +371,111 @@\n             values = []\n             for v in line.split(delimiter):\n+                if v.upper() == \"NO\":\n+                    values.append(np.ma.masked)\n+                else:\n+                    # Understand if number is int or float\n+                    try:\n+                        values.append(int(v))\n+                    except ValueError:\n+                        values.append(float(v))\n+            current_rows.append(values)\n+            continue\n+\n+        if datatype == \"new\":\n+            # Save table to table_list and reset\n+            if current_rows is not None:\n+                new_table = Table(names=colnames, rows=current_rows)\n+                new_table.meta[\"initial_comments\"] = initial_comments.strip().split(\n+                    \"\\n\"\n+                )\n+                new_table.meta[\"comments\"] = comment_text.strip().split(\"\\n\")\n+                # Reset comments\n+                comment_text = \"\"\n+                table_list.append(new_table)\n+                current_rows = None\n+            continue\n+\n+    # At the very end, if there is still a table being written, let's save\n+    # it to the table_list\n+    if current_rows is not None:\n+        new_table = Table(names=colnames, rows=current_rows)\n+        new_table.meta[\"initial_comments\"] = initial_comments.strip().split(\"\\n\")\n+        new_table.meta[\"comments\"] = comment_text.strip().split(\"\\n\")\n+        table_list.append(new_table)\n+\n+    return table_list\n+    \"\"\"Get all tables from a QDP file.\n+\n+    Parameters\n+    ----------\n+    qdp_file : str\n+        Input QDP file name\n+\n+    Other Parameters\n+    ----------------\n+    input_colnames : list of str\n+        Name of data columns (defaults to ['col1', 'col2', ...]), _not_\n+        including error columns.\n+    delimiter : str\n+        Delimiter for the values in the table.\n+\n+    Returns\n+    -------\n+    list of `~astropy.table.Table`\n+        List containing all the tables present inside the QDP file\n+    \"\"\"\n+    lines = _get_lines_from_file(qdp_file)\n+    contents, ncol = _get_type_from_list_of_lines(lines, delimiter=delimiter)\n+\n+    table_list = []\n+    err_specs = {}\n+    colnames = None\n+\n+    comment_text = \"\"\n+    initial_comments = \"\"\n+    command_lines = \"\"\n+    current_rows = None\n+\n+    for line, datatype in zip(lines, contents):\n+        line = line.strip().lstrip(\"!\")\n+        # Is this a comment?\n+        if datatype == \"comment\":\n+            comment_text += line + \"\\n\"\n+            continue\n+\n+        if datatype == \"command\":\n+            # The first time I find commands, I save whatever comments into\n+            # The initial comments.\n+            if command_lines == \"\":\n+                initial_comments = comment_text\n+                comment_text = \"\"\n+\n+            if err_specs != {}:\n+                warnings.warn(\n+                    \"This file contains multiple command blocks. Please verify\",\n+                    AstropyUserWarning,\n+                )\n+            command_lines += line + \"\\n\"\n+            continue\n+\n+        if datatype.startswith(\"data\"):\n+            # The first time I find data, I define err_specs\n+            if err_specs == {} and command_lines != \"\":\n+                for cline in command_lines.strip().split(\"\\n\"):\n+                    command = cline.strip().split()\n+                    # This should never happen, but just in case.\n+                    if len(command) < 3:\n+                        continue\n+                    err_specs[command[1].lower()] = [int(c) for c in command[2:]]\n+            if colnames is None:\n+                colnames = _interpret_err_lines(err_specs, ncol, names=input_colnames)\n+\n+            if current_rows is None:\n+                current_rows = []\n+\n+            values = []\n+            for v in line.split(delimiter):\n                 if v == \"NO\":\n                     values.append(np.ma.masked)\n                 else:\n", "model_name_or_path": "test-aware-debugging"}
